const assert = require('assert');

const ShapeConverter = require('./tools/shape-converter');
const {getDimensions, removeNonNumeric} = require('./tools/svg-dimens');
const svgColor = require('./tools/svg-color');
const svgPathToSwift = require('./tools/svg-path-to-swift');
const optimizeSvg = require('./tools/optimize-svg');
const substituteDefs = require('./plugins/substitute-defs');
const insertStyle = require('./plugins/insert-style')
const removeInvisiblePaintElems = require('./plugins/remove-invisible-paint-elems')
const moveGroupPaintToElems = require('./plugins/move-group-paint-to-elems')
const StringBuilder = require('./tools/string-builder');
const parseXmlString = require('./tools/parse-xml-string');
const autoIndent = require('./tools/auto-indent');

const rootLayerName = 'rootLayer';
const pathName = 'path';
const extension = '.swift'

function convert(inputXml, {codeIndent, codeType, version} = {}) {

  assert(typeof codeIndent == 'string', 'codeIndent must be a string');
  assert(/^\s*$/.test(codeIndent), 'codeIndent must be whitespace only');
  assert(['AppKit', 'UIKit'].indexOf(codeType) !== -1, 'codeType must be either "AppKit" or "UIKit"');

  return optimizeSvg(inputXml, {
      noArcs: true,
      custom: [insertStyle, substituteDefs, moveGroupPaintToElems, removeInvisiblePaintElems]
    })
    .then(xml => parseXmlString(xml))
    .then(xml => generateCode(xml));

  function generateCode(xml) {
    var generatedOutput = '';

    var svg = xml.svg;
    var dimensions = getDimensions(svg);
    var baseStyle = svg.$;
    var name = getNameForLevel(0);

    generatedOutput = new StringBuilder();
    generatedOutput.appendFormat('let {0} = CAShapeLayer() // Generated by Svgsus\n', getNameForLevel(0));

    recursiveTreeWalk(svg, baseStyle, 0, generatedOutput);
    printEnd(name, dimensions, generatedOutput);

    return generatedOutput.toString();
  }

  function printEnd(name, dimensions, generatedOutput) {
    if(codeType == 'AppKit') {
      generatedOutput.append('let scaleTransform = CATransform3DMakeScale(1, -1, 1)\n');
      generatedOutput.append(`let translateTransform = CATransform3DMakeTranslation(0, ${dimensions.height}, 0)\n`);
      generatedOutput.append('let transform = CATransform3DConcat(scaleTransform, translateTransform)\n');
      generatedOutput.append(`${name}.transform = transform\n`);
    }
    if(dimensions.width && dimensions.height) {
      generatedOutput.append(`${name}.bounds = CGRect(x: ${dimensions.x}, y: ${dimensions.y}, width: ${dimensions.width}, height: ${dimensions.height})\n`);
      generatedOutput.append(`${name}.anchorPoint = CGPoint(x: 0, y: 0)\n`);
    }
  }

  function recursiveTreeWalk(parent, baseStyle, groupLevel, generatedOutput) {
    var isArray = Array.isArray(parent);

    for (var key in parent) {
      var current = parent[key];
      if(isArray) {
        for(var arrayKey in current) {
          var innerArray = current[arrayKey]
          innerArray.forEach(function(item) {
            recursiveTreeWalkItem(arrayKey, item, baseStyle, groupLevel, generatedOutput);
          })
        }
      } else {
        if(Array.isArray(current)) {
          current.forEach(function(item) {
            recursiveTreeWalkItem(key, item, baseStyle, groupLevel, generatedOutput);
          })
        } else {
          recursiveTreeWalkItem(key, current, baseStyle, groupLevel, generatedOutput);
        }
      }
    }
  }

  function recursiveTreeWalkItem(key, current, baseStyle, groupLevel, generatedOutput) {
    if(key == 'g' && Object.keys.length > 0) {
      var group = parseGroup(current);
      var groupIsValid = group.isSet; // TODO Add this to user preferences, or force?
      if (groupIsValid) printGroupStart(group, groupLevel, generatedOutput);
      if (groupIsValid) groupLevel++;
      recursiveTreeWalk(current, appendGroupStyles(current.$, baseStyle), groupLevel, generatedOutput);
      if (groupIsValid) groupLevel--;
      if (groupIsValid) printGroupEnd(groupLevel, generatedOutput);

    } else if (key == 'path') {
      var pathD = parsePathD(current);
      if (pathD != null) {
        printPath(pathD, [current.$, baseStyle], groupLevel, generatedOutput);
      } else {
        console.warn('found path(s) without data (empty or invalid parameter <i>d</i>)');
      }
    } else if (key == 'line') {
      printPath(ShapeConverter.convertLine(current.$), [current.$, baseStyle], groupLevel, generatedOutput);
    } else if (key == 'rect') {
      printPath(ShapeConverter.convertRect(current.$), [current.$, baseStyle], groupLevel, generatedOutput);
    } else if (key == 'circle') {
      printPath(ShapeConverter.convertCircle(current.$), [current.$, baseStyle], groupLevel, generatedOutput);
    } else if (key == 'ellipse') {
      printPath(ShapeConverter.convertEllipse(current.$), [current.$, baseStyle], groupLevel, generatedOutput);
    } else if (key == 'polyline') {
      printPath(ShapeConverter.convertPolygon(current.$, true), [current.$, baseStyle], groupLevel, generatedOutput);
    } else if (key == 'polygon') {
      printPath(ShapeConverter.convertPolygon(current.$, false), [current.$, baseStyle], groupLevel, generatedOutput);
    } else if (key == 'text') {
      console.warn('<i>text</i> element is not supported, export all text into path');
    }
  }

  function appendGroupStyles(groupStyle, baseStyle) {
    let styles = {};
    for(var styleName in groupStyle) {
      styles[styleName] = groupStyle[styleName];
    }
    for (var styleName in baseStyle) {
      if (typeof styles[styleName] === 'undefined') {
        styles[styleName] = baseStyle[styleName]
      }
    }
    return styles;
  }

  function parseGroup(groupTag) {
    var transform = groupTag.$ ? groupTag.$.transform : undefined;
    var id = groupTag.$ ? groupTag.$.id : undefined;
    var groupTransform = {transformX: 0, transformY: 0, scaleX: 1, scaleY: 1, rotate:0, rotatePivotX:-1, rotatePivotY:-1, id:'', isSet:false};
    if (typeof transform !== 'undefined') {
      var regex = /((\w|\s)+)\(([^)]+)/mg;
      var result;
      while (result = regex.exec(transform)) {
        var split = result[3].split(/[,\s]+/);
        var transformName = result[1].trim();
        if (transformName == 'translate') {
          groupTransform.transformX = split[0];
          groupTransform.transformY = split[1] || 0;
          groupTransform.isSet = true;
        } else if (transformName == 'scale') {
          groupTransform.scaleX = split[0];
          groupTransform.scaleY = split[1] || 0;
          groupTransform.isSet = true;
        } else if (transformName == 'rotate') {
          groupTransform.rotate = split[0];
          groupTransform.rotatePivotX = split[1] || -1;
          groupTransform.rotatePivotY = split[2] || -1;
          groupTransform.isSet = true;
        } else {
          console.error('group transform \'<i>' + transformName + '</i>\' is not supported, use option <i>Bake transforms into path</i>');
        }
      }
    }
    if (typeof id !== 'undefined') {
      groupTransform.id = id;
    }

    return groupTransform;
  }

  function parsePathD(pathData) {
    const DRAW_LINE = 'l'; //used as default parameter when no found in path
    const START_PATH = 'M';
    const END_PATH = 'Z';

    var path = pathData.$ ? pathData.$.d : undefined;

    if (typeof path === 'undefined') {
      return null;
    }

    path = path.replace(/\s{2,}/g, ' '); //replace extra spaces

    if (path.match(/-?\d*\.?\d+e[+-]?\d+/g)) {
      console.warn('found some numbers with scientific E notation in pathData which probably isn\'t supported. ' +
      'Please fix It manually by editing your editor precision or manually by editing pathData');
    }

    //Check path If contains draw otherwise use default l
    var pathStart = false, bigM = false, skipMove = false, stop = false;
    var pathRebuild = '';
    path.split(' ').forEach(function (t) {
      if (stop) {
        pathRebuild += t + ' ';
        return;
      }

      if (t.toUpperCase() == START_PATH) {
        pathStart = true;
        bigM = t == START_PATH;
      } else if (skipMove && pathStart) {
        if (!(t.indexOf(',') == -1 && isNaN(t))) {
          t = (bigM ? DRAW_LINE.toUpperCase() : DRAW_LINE) + ' ' + t;
        }
        stop = true;
      } else if (pathStart) {
        skipMove = true;
      }

      pathRebuild += t + ' ';
    });

    pathRebuild; // TODO why is this built? (used here to please eslint)
    path = path.replace(/^\s*m/, START_PATH).replace(/^\s*z/, END_PATH); // Fix path positioning
    path = path.replace(/(\.\d+)(\.\d+)\s?/g, '\$1 \$2 '); // Fix path formatting

    if (!path.endsWith(' ')) {
      path += ' ';
    }
    return path;
  }

  function printGroupStart(groupTransform, groupLevel, generatedOutput) {
    var name = getNameForLevel(groupLevel + 1);

    generatedOutput.append(codeIndent.repeat(groupLevel)  +'({\n');
    generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + 'let {0} = CAShapeLayer()\n', name);
    generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + 'let translateTransform = CATransform3DMakeTranslation({0}, {1}, 0)\n', groupTransform.transformX, groupTransform.transformY);
    generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + 'let scaleTransform = CATransform3DMakeScale({0}, {1}, 1)\n', groupTransform.scaleX, groupTransform.scaleY);
    generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + '{0}.transform = CATransform3DConcat(translateTransform, scaleTransform)\n', name);
  }

  function printGroupEnd(groupLevel, generatedOutput) {
    generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + '{0}.addSublayer({1})\n', getNameForLevel(groupLevel), getNameForLevel(groupLevel + 1));
    generatedOutput.append(codeIndent.repeat(groupLevel) + '})()\n');
  }

  function getNameForLevel(groupLevel) {
    if(groupLevel == 0) {
      return rootLayerName;
    }
    return 'layer' + groupLevel;
  }

  function printPath(pathData, stylesArray, groupLevel, generatedOutput) {
    var styles = stylesArray[0];
    var parentGroupStyles = stylesArray[1];

    if (pathData == null) {
      return;
    }

    if (styles.hasOwnProperty('transform')) {
      console.warn('transforms on path are not supported, use option <i>Bake transforms into path</i>');
    }

    if (parentGroupStyles != null) {
      //Inherit styles from group first
      for (var styleName in parentGroupStyles) {
        if (typeof styles[styleName] === 'undefined') {
          styles[styleName] = parentGroupStyles[styleName];
        }
      }
    }
    //Parent opacity setting - multiply fill-opacity and stroke-opacity
    var opacity = styles['opacity'];
    if (typeof opacity !== 'undefined') {
      if (typeof styles['fill-opacity'] !== 'undefined') {
        styles['fill-opacity'] *= opacity;
      } else {
        styles['fill-opacity'] = opacity;
      }
      if (typeof styles['stroke-opacity'] !== 'undefined') {
        styles['stroke-opacity'] *= opacity;
      } else {
        styles['stroke-opacity'] = opacity;
      }
    }

    //If fill is omitted use default black
    if (typeof styles['fill'] === 'undefined') {
      styles['fill'] = '#000000';
    }

    var name = getNameForLevel(groupLevel + 1)

    generatedOutput.append(codeIndent.repeat(groupLevel)  +'({\n');
    generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + 'let {0} = CAShapeLayer()\n', name);
    generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + '{0}.fillColor = {1}\n', name, parseColorToCGColor(styles['fill'], styles['fill-opacity'] || 1));
    generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + '{0}.strokeColor = {1}\n', name, parseColorToCGColor(styles['stroke'], styles['stroke-opacity'] || 1));
    generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + '{0}.lineWidth = {1}\n', name, removeNonNumeric(styles['stroke-width']) || 0);
    if(styles['stroke-linejoin']) {
      generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + '{0}.lineJoin = {1}\n', name, parseLineJoin(styles['stroke-linejoin']));
    }
    if(styles['stroke-linecap']) {
      generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + '{0}.lineCap = {1}\n', name, parseLineCap(styles['stroke-linecap']));
    }
    if(styles['stroke-miterlimit']) {
      generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + '{0}.miterLimit = {1}\n', name, styles['stroke-miterlimit'] || 10);
    }
    if(styles['fill-rule']) {
      generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + '{0}.fillRule = {1}\n', name, parseFillRule(styles['fill-rule']));
    }
    generatedOutput.appendFormat(codeIndent.repeat(groupLevel + 1) + '{0}.addSublayer({1})\n', getNameForLevel(groupLevel), name);

    generatedOutput.append(svgPathToSwift({
      codeIndent: codeIndent.repeat(groupLevel + 1),
      layer: name,
      pathData,
      codeType,
      pathName,
      version
    }));

    generatedOutput.append(codeIndent.repeat(groupLevel) + '})()\n');
  }

  function parseFillRule(fillRule) {
    if(fillRule == 'evenodd') return 'kCAFillRuleEvenOdd';
    return 'kCAFillRuleNonZero';
  }

  function parseLineJoin(linejoin) {
    if(typeof linejoin === 'undefined') return 'kCALineJoinMiter';
    if(linejoin == 'miter') return 'kCALineJoinMiter';
    if(linejoin == 'round') return 'kCALineJoinRound';
    return 'kCALineJoinBevel';
  }

  function parseLineCap(linecap) {
    if(typeof linecap === 'undefined') return 'kCALineCapButt';
    if(linecap == 'butt') return 'kCALineCapButt';
    if(linecap == 'round') return 'kCALineCapRound';
    return 'kCALineCapSquare';
  }

  function parseColorToCGColor(c, a) {
    var color = svgColor(c);
    if(!color.none()) {
      color.alpha(a);
    }
    var kitColor = codeType == 'AppKit' ? color.nscolor() : color.uicolor();
    return `${kitColor}.CGColor`;
  }
}

function convertAll(contents, options = {}) {
  const codeIndent = options.codeIndent;
  assert(typeof codeIndent == 'string', 'codeIndent must be a string');
  assert(/^\s*$/.test(codeIndent), 'codeIndent must be whitespace only');

  function varName(str) {
    // logo.svgsus-large home.svg => logoSvgsusLargeHomeSvg
    var arr = str.split(/[ ,.-]+/);
    for(var i=0,l=arr.length; i<l; i++) {
        arr[i] = arr[i].substr(0,1)[i == 0 ? 'toLowerCase' : 'toUpperCase']() +
                 (arr[i].length > 1 ? arr[i].substr(1).toLowerCase() : '');
    }
    return arr.join('');
  }

  function fileName() {
    if (contents.length) {
      return [
        varName(contents[0].name),
        contents.length > 1 ? '+' + (contents.length - 1) : '',
        extension
      ].join('');
    } else {
      return 'svgsus' + extension
    }
  }

  function joinContents(items) {
    let results = '';
    items.forEach(item => {
      results += `var ${varName(item.name)}: CAShapeLayer = {\n`
        + `${item.converted}\n`
        + `return ${rootLayerName}\n`
        + '}()\n\n';
    });
    return results;
  }

  return Promise.all(contents.map(content => convert(content.svg, options)
      .then(converted => ({ converted, name: content.name })
    )))
    .then(separated => ([{ name: fileName(), code: autoIndent(extension, joinContents(separated), codeIndent) }]))
}

exports.extension = extension;
exports.convertAll = convertAll;
exports.convert = convert;
