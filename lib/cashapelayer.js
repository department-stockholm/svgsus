const assert = require('assert')

const ShapeConverter = require('./tools/shape-converter')
const {getDimensions, removeNonNumeric} = require('./tools/svg-dimens')
const {swiftFormatter} = require('./tools/swift-formatter')
const svgPathToSwift = require('./tools/svg-path-to-swift')
const optimizeSvg = require('./tools/optimize-svg')
const substituteDefs = require('./plugins/substitute-defs')
const insertStyle = require('./plugins/insert-style')
const removeInvisiblePaintElems = require('./plugins/remove-invisible-paint-elems')
const moveGroupPaintToElems = require('./plugins/move-group-paint-to-elems')
const parseXmlString = require('./tools/parse-xml-string')
const autoIndent = require('./tools/auto-indent')

const rootLayerName = 'rootLayer'
const pathName = 'path'
const extension = '.swift'

function convert (inputXml, {codeIndent, codeType, version} = {}) {
  assert(typeof codeIndent === 'string', 'codeIndent must be a string')
  assert(/^\s*$/.test(codeIndent), 'codeIndent must be whitespace only')
  assert(['AppKit', 'UIKit'].indexOf(codeType) !== -1, 'codeType must be either "AppKit" or "UIKit"')

  const formatter = swiftFormatter({version, framework: codeType})
  return optimizeSvg(inputXml, {
    noArcs: true,
    custom: [insertStyle, substituteDefs, moveGroupPaintToElems, removeInvisiblePaintElems]
  })
  .then(outputXml => parseXmlString(outputXml))
  .then(outputXml => generateCode(outputXml, formatter))


  function generateCode (xml, formatter) {
    let svg = xml.svg
    let dimensions = getDimensions(svg)
    let baseStyle = svg.$
    let name = getNameForLevel(0)
    let output = {text: ''}
    output.text += `let ${getNameForLevel(0)} = ${formatter.initShape()} // Generated by Svgsus\n`
    // generatedOutput.appendFormat('let {0} = CAShapeLayer() // Generated by Svgsus\n', getNameForLevel(0));
    recursiveTreeWalk(svg, baseStyle, 0, output, formatter)
    printEnd(name, dimensions, output, formatter)
    return output.text
  }

  function printEnd (name, dimensions, output, formatter) {
    if (formatter.framework === 'AppKit') {
      output.text += `let scaleTransform = ${formatter.scale3d({x: 1, y: -1, z: 1})}\n`
      output.text += `let translateTransform = ${formatter.translate3d({x: 0, y: dimensions.height, z: 0})}\n`
      output.text += `let transform = ${formatter.concat3d('scaleTransform', 'translateTransform')}\n`
      output.text += `${name}.transform = transform\n`
    }
    if (dimensions.width && dimensions.height) {
      output.text += `${name}.bounds = ${formatter.initRect(dimensions)}\n`
      output.text += `${name}.anchorPoint = ${formatter.initPoint({x: 0, y: 0})}\n`
    }
  }

  function recursiveTreeWalk (parent, baseStyle, groupLevel, output, formatter) {
    var isArray = Array.isArray(parent)

    for (var key in parent) {
      var current = parent[key]
      if (isArray) {
        for (var arrayKey in current) {
          var innerArray = current[arrayKey]
          innerArray.forEach(function (item) {
            recursiveTreeWalkItem(arrayKey, item, baseStyle, groupLevel, output, formatter)
          })
        }
      } else {
        if (Array.isArray(current)) {
          current.forEach(function (item) {
            recursiveTreeWalkItem(key, item, baseStyle, groupLevel, output, formatter)
          })
        } else {
          recursiveTreeWalkItem(key, current, baseStyle, groupLevel, output, formatter)
        }
      }
    }
  }

  function recursiveTreeWalkItem (key, current, baseStyle, groupLevel, output, formatter) {
    if (key === 'g' && Object.keys.length > 0) {
      var group = parseGroup(current)
      var groupIsValid = group.isSet // TODO Add this to user preferences, or force?
      if (groupIsValid) printGroupStart(group, groupLevel, output, formatter)
      if (groupIsValid) groupLevel++
      recursiveTreeWalk(current, appendGroupStyles(current.$, baseStyle), groupLevel, output, formatter)
      if (groupIsValid) groupLevel--
      if (groupIsValid) printGroupEnd(groupLevel, output, formatter)
    } else if (key === 'path') {
      var pathD = parsePathD(current)
      if (pathD != null) {
        printPath(pathD, [current.$, baseStyle], groupLevel, output, formatter)
      } else {
        console.warn('found path(s) without data (empty or invalid parameter <i>d</i>)')
      }
    } else if (key === 'line') {
      printPath(ShapeConverter.convertLine(current.$), [current.$, baseStyle], groupLevel, output, formatter)
    } else if (key === 'rect') {
      printPath(ShapeConverter.convertRect(current.$), [current.$, baseStyle], groupLevel, output, formatter)
    } else if (key === 'circle') {
      printPath(ShapeConverter.convertCircle(current.$), [current.$, baseStyle], groupLevel, output, formatter)
    } else if (key === 'ellipse') {
      printPath(ShapeConverter.convertEllipse(current.$), [current.$, baseStyle], groupLevel, output, formatter)
    } else if (key === 'polyline') {
      printPath(ShapeConverter.convertPolygon(current.$, true), [current.$, baseStyle], groupLevel, output, formatter)
    } else if (key === 'polygon') {
      printPath(ShapeConverter.convertPolygon(current.$, false), [current.$, baseStyle], groupLevel, output, formatter)
    } else if (key === 'text') {
      console.warn('<i>text</i> element is not supported, export all text into path')
    }
  }

  function appendGroupStyles (groupStyle, baseStyle) {
    let styles = {}
    for (let styleName in groupStyle) {
      styles[styleName] = groupStyle[styleName]
    }
    for (let styleName in baseStyle) {
      if (typeof styles[styleName] === 'undefined') {
        styles[styleName] = baseStyle[styleName]
      }
    }
    return styles
  }

  function parseGroup (groupTag) {
    var transform = groupTag.$ ? groupTag.$.transform : undefined
    var id = groupTag.$ ? groupTag.$.id : undefined
    var groupTransform = {
      transformX: 0,
      transformY: 0,
      scaleX: 1,
      scaleY: 1,
      rotate: 0,
      rotatePivotX: -1,
      rotatePivotY: -1,
      id: '',
      isSet: false
    }
    if (typeof transform !== 'undefined') {
      var regex = /((\w|\s)+)\(([^)]+)/mg
      var result
      while ((result = regex.exec(transform))) {
        var split = result[3].split(/[,\s]+/)
        var transformName = result[1].trim()
        if (transformName === 'translate') {
          groupTransform.transformX = split[0]
          groupTransform.transformY = split[1] || 0
          groupTransform.isSet = true
        } else if (transformName === 'scale') {
          groupTransform.scaleX = split[0]
          groupTransform.scaleY = split[1] || 0
          groupTransform.isSet = true
        } else if (transformName === 'rotate') {
          groupTransform.rotate = split[0]
          groupTransform.rotatePivotX = split[1] || -1
          groupTransform.rotatePivotY = split[2] || -1
          groupTransform.isSet = true
        } else {
          console.error('group transform \'<i>' + transformName + '</i>\' is not supported, use option <i>Bake transforms into path</i>')
        }
      }
    }
    if (typeof id !== 'undefined') {
      groupTransform.id = id
    }
    return groupTransform
  }

  function parsePathD (pathData) {
    const DRAW_LINE = 'l' // used as default parameter when no found in path
    const START_PATH = 'M'
    const END_PATH = 'Z'

    var path = pathData.$ ? pathData.$.d : undefined

    if (typeof path === 'undefined') {
      return null
    }

    path = path.replace(/\s{2,}/g, ' ') // replace extra spaces

    if (path.match(/-?\d*\.?\d+e[+-]?\d+/g)) {
      console.warn('found some numbers with scientific E notation in pathData which probably isn\'t supported. ' +
      'Please fix It manually by editing your editor precision or manually by editing pathData')
    }

    // Check path If contains draw otherwise use default l
    var pathStart = false
    var bigM = false
    var skipMove = false
    var stop = false
    var pathRebuild = ''
    path.split(' ').forEach(function (t) {
      if (stop) {
        pathRebuild += t + ' '
        return
      }
      if (t.toUpperCase() == START_PATH) {
        pathStart = true
        bigM = t == START_PATH
      } else if (skipMove && pathStart) {
        if (!(t.indexOf(',') === -1 && isNaN(t))) {
          t = (bigM ? DRAW_LINE.toUpperCase() : DRAW_LINE) + ' ' + t
        }
        stop = true
      } else if (pathStart) {
        skipMove = true
      }
      pathRebuild += t + ' '
    })

    pathRebuild // TODO why is this built? (used here to please eslint)
    path = path.replace(/^\s*m/, START_PATH).replace(/^\s*z/, END_PATH) // Fix path positioning
    path = path.replace(/(\.\d+)(\.\d+)\s?/g, '$1 $2 ') // Fix path formatting

    if (!path.endsWith(' ')) {
      path += ' '
    }
    return path
  }

  function printGroupStart (groupTransform, groupLevel, output, formatter) {
    const name = getNameForLevel(groupLevel + 1)
    const indent = codeIndent.repeat(groupLevel + 1)
    output.text += `${codeIndent.repeat(groupLevel)}({\n`
    output.text += `${indent}let ${name} = ${formatter.initShape()}\n`
    output.text += `${indent}let translateTransform = ${formatter.translate3d({
      x: groupTransform.transformX,
      y: groupTransform.transformY,
      z: 0
    })}\n`
    output.text += `${indent}let scaleTransform = ${formatter.scale3d({
      x: groupTransform.scaleX,
      y: groupTransform.scaleY,
      z: 1
    })}\n`
    output.text += `${indent}${name}.transform = ${formatter.concat3d('translateTransform', 'scaleTransform')}\n`
  }

  function printGroupEnd (groupLevel, output, formatter) {
    output.text += `${codeIndent.repeat(groupLevel + 1)}
      ${getNameForLevel(groupLevel)}
      .${formatter.addLayer(getNameForLevel(groupLevel + 1))}\n`
    output.text += `${codeIndent.repeat(groupLevel)}})()\n`
  }

  function getNameForLevel (groupLevel) {
    if (groupLevel === 0) {
      return rootLayerName
    }
    return 'layer' + groupLevel
  }

  function printPath (pathData, stylesArray, groupLevel, output, formatter) {
    const styles = stylesArray[0]
    const parentGroupStyles = stylesArray[1]
    if (pathData === null) {
      return
    }
    if (styles.hasOwnProperty('transform')) {
      console.warn('transforms on path are not supported')
    }
    if (parentGroupStyles != null) {
        // Inherit styles from group first
      for (var styleName in parentGroupStyles) {
        if (typeof styles[styleName] === 'undefined') {
          styles[styleName] = parentGroupStyles[styleName]
        }
      }
    }
      // Parent opacity setting - multiply fill-opacity and stroke-opacity
    const opacity = styles['opacity']
    if (typeof opacity !== 'undefined') {
      if (typeof styles['fill-opacity'] !== 'undefined') {
        styles['fill-opacity'] *= opacity
      } else {
        styles['fill-opacity'] = opacity
      }
      if (typeof styles['stroke-opacity'] !== 'undefined') {
        styles['stroke-opacity'] *= opacity
      } else {
        styles['stroke-opacity'] = opacity
      }
    }
      // If fill is omitted use default black
    if (typeof styles['fill'] === 'undefined') {
      styles['fill'] = '#000000'
    }
    const name = getNameForLevel(groupLevel + 1)
    const indent = codeIndent.repeat(groupLevel + 1)
    output.text += `${codeIndent.repeat(groupLevel)}({\n`
    output.text += `${indent}let ${name} = ${formatter.initShape()}\n`
    output.text += `${indent}${name}.${formatter.fillColor} = ${formatter.toCGColor({
      text: styles['fill'],
      alpha: styles['fill-opacity'] || 1
    })}\n`
    output.text += `${indent}${name}.${formatter.strokeColor} = ${formatter.toCGColor({
      text: styles['stroke'],
      alpha: styles['stroke-opacity'] || 1
    })}\n`
    output.text += `${indent}${name}.${formatter.lineWidth} = ${removeNonNumeric(styles['stroke-width']) || 0}\n`
    if (styles['stroke-linejoin']) {
      output.text += `${indent}${name}.${formatter.lineJoin} = ${parseLineJoin(styles['stroke-linejoin'])}\n`
    }
    if (styles['stroke-linecap']) {
      output.text += `${indent}${name}.${formatter.lineCap} = ${parseLineCap(styles['stroke-linecap'])}\n`
    }
    if (styles['stroke-miterlimit']) {
      output.text += `${indent}${name}.${formatter.miterlimit} = ${styles['stroke-miterlimit'] || 10}\n`
    }
    if (styles['fill-rule']) {
      output.text += `${indent}${name}.${formatter.fillRule} = ${parseFillRule(styles['fill-rule'])}\n`
    }
    output.text += `${indent}${getNameForLevel(groupLevel)}.${formatter.addLayer(name)}\n`
    output.text += svgPathToSwift({
      codeIndent: codeIndent.repeat(groupLevel + 1),
      layer: name,
      pathData,
      codeType,
      pathName,
      version,
      formatter
    })
    output.text += `${codeIndent.repeat(groupLevel)}})()\n`
  }

  function parseFillRule (fillRule) {
    if (fillRule === 'evenodd') return 'kCAFillRuleEvenOdd'
    return 'kCAFillRuleNonZero'
  }

  function parseLineJoin (linejoin) {
    if (typeof linejoin === 'undefined') return 'kCALineJoinMiter'
    if (linejoin === 'miter') return 'kCALineJoinMiter'
    if (linejoin === 'round') return 'kCALineJoinRound'
    return 'kCALineJoinBevel'
  }

  function parseLineCap (linecap) {
    if (typeof linecap === 'undefined') return 'kCALineCapButt'
    if (linecap === 'butt') return 'kCALineCapButt'
    if (linecap === 'round') return 'kCALineCapRound'
    return 'kCALineCapSquare'
  }
}

function convertAll (contents, options = {}) {
  const codeIndent = options.codeIndent
  assert(typeof codeIndent === 'string', 'codeIndent must be a string')
  assert(/^\s*$/.test(codeIndent), 'codeIndent must be whitespace only')

  function varName (str) {
    // logo.svgsus-large home.svg => logoSvgsusLargeHomeSvg
    var arr = str.split(/[ ,.-]+/)
    for (var i = 0, l = arr.length; i < l; i++) {
      arr[i] = arr[i].substr(0, 1)[i === 0 ? 'toLowerCase' : 'toUpperCase']() +
      (arr[i].length > 1 ? arr[i].substr(1).toLowerCase() : '')
    }
    return arr.join('')
  }

  function fileName () {
    if (contents.length) {
      return [
        varName(contents[0].name),
        contents.length > 1 ? '+' + (contents.length - 1) : '',
        extension
      ].join('')
    } else {
      return 'svgsus' + extension
    }
  }

  function joinContents (items) {
    let results = ''
    items.forEach(item => {
      results += `var ${varName(item.name)}: CAShapeLayer = {\n` +
        `${item.converted}\n` +
        `return ${rootLayerName}\n` +
        '}()\n\n'
    })
    return results
  }

  return Promise.all(contents.map(content => convert(content.svg, options)
        .then(converted => ({ converted, name: content.name }))))
      .then(separated => ([{ name: fileName(), code: autoIndent(extension, joinContents(separated), codeIndent) }]))
}

exports.extension = extension
exports.convertAll = convertAll
exports.convert = convert
